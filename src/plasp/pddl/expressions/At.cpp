#include <plasp/pddl/expressions/At.h>

#include <plasp/output/TranslatorException.h>

namespace plasp
{
namespace pddl
{
namespace expressions
{

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// At
//
////////////////////////////////////////////////////////////////////////////////////////////////////

At::At()
:	m_argument{nullptr}
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////

ExpressionPointer At::copy()
{
	auto result = new At;

	result->m_argument = m_argument->copy();

	return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void At::setArgument(ExpressionPointer argument)
{
	m_argument = argument;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

ExpressionPointer At::argument() const
{
	return m_argument;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

ExpressionPointer At::reduced()
{
	throw output::TranslatorException("reducing “at” predicates currently not supported");
}

////////////////////////////////////////////////////////////////////////////////////////////////////

ExpressionPointer At::negationNormalized()
{
	BOOST_ASSERT(m_argument);

	m_argument = m_argument->negationNormalized();

	return this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

ExpressionPointer At::prenex(Expression::Type lastExpressionType)
{
	BOOST_ASSERT(m_argument);

	m_argument = m_argument->prenex(lastExpressionType);

	return Expression::moveUpQuantifiers(this, m_argument);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

ExpressionPointer At::simplified()
{
	BOOST_ASSERT(m_argument);

	m_argument = m_argument->simplified();

	return this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

ExpressionPointer At::disjunctionNormalized()
{
	BOOST_ASSERT(m_argument);

	m_argument = m_argument->disjunctionNormalized();

	return this;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void At::print(std::ostream &ostream) const
{
	ostream << "(at " << m_timePoint << " ";

	m_argument->print(ostream);

	ostream << ")";
}

////////////////////////////////////////////////////////////////////////////////////////////////////

}
}
}
