#include <plasp/pddl/Variable.h>

#include <boost/assert.hpp>

#include <plasp/pddl/Context.h>
#include <plasp/pddl/Identifier.h>
#include <plasp/pddl/Type.h>

namespace plasp
{
namespace pddl
{

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Variable
//
////////////////////////////////////////////////////////////////////////////////////////////////////

Variable::Variable(std::string name)
:	m_isDirty{false},
	m_name(name)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////

Variable Variable::parse(utils::Parser &parser)
{
	parser.skipWhiteSpace();

	parser.expect<std::string>("?");

	const auto variableName = parser.parseIdentifier(isIdentifier);

	Variable variable(variableName);
	variable.setDirty();

	return variable;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void Variable::parseTyped(utils::Parser &parser, Context &context, std::vector<Variable> &variables)
{
	// Parse and store variable itself
	variables.emplace_back(parse(parser));

	parser.skipWhiteSpace();

	// Check if the variable has a type declaration
	if (!parser.advanceIf('-'))
		return;

	// Parse argument type
	const auto type = parseType(parser, context);

	// Set the argument type for all previously flagged arguments
	std::for_each(variables.begin(), variables.end(),
		[&](auto &variable)
		{
			if (!variable.isDirty())
				return;

			variable.setType(type);
			variable.setDirty(false);
		});
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void Variable::setDirty(bool isDirty)
{
	m_isDirty = isDirty;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

bool Variable::isDirty() const
{
	return m_isDirty;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

const std::string &Variable::name() const
{
	return m_name;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

void Variable::setType(TypePtr type)
{
	m_type = type;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

TypePtr Variable::type() const
{
	return m_type;
}

////////////////////////////////////////////////////////////////////////////////////////////////////

}
}
